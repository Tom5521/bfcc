// this package handles turning a brainfuck program into an output
// that can be compiled (generally C or ASM)
package gen

import (
	"bfcc/lexer"
	"bytes"
	"fmt"
	"os"
	"os/exec"
)

type Generator interface {
	// takes program input, and creates outfile
	Generate(input string, outpath string) error
}

type GenC struct {
	input   string
	output  string
	memsize uint
}

func New(memsize uint) *GenC {
	return &GenC{
		memsize: memsize,
	}
}

func (c *GenC) generateSrc() ([]byte, error) {
	var buf bytes.Buffer
	var start = `
/* 
* This program is auto-generated by bfcc
* sweetbbak
*/

#include <stdio.h>
char array[%d];
int idx = 0;

int main(int argc, char *argv[]) {
        `

	// add memory size to header
	start = fmt.Sprintf(start, c.memsize)
	buf.WriteString(start)

	// create a lexer based on input
	l := lexer.New(c.input)

	// actual program parsing
	program := l.Tokens()

	token_index := 0
	for token_index < len(program) {
		// the current token
		tok := program[token_index]

		switch tok.Type {
		case lexer.INC_PTR:
			buf.WriteString(fmt.Sprintf("  idx += %d;\n", tok.Repeat))
		case lexer.DEC_PTR:
			buf.WriteString(fmt.Sprintf("  idx -= %d;\n", tok.Repeat))
		case lexer.INC_CELL:
			buf.WriteString(fmt.Sprintf("  array[idx] += %d;\n", tok.Repeat))
		case lexer.DEC_CELL:
			buf.WriteString(fmt.Sprintf("  array[idx] -= %d;\n", tok.Repeat))
		case lexer.OUTPUT:
			buf.WriteString("   putchar(array[idx]);\n")
		case lexer.INPUT:
			buf.WriteString("   array[idx] = getchar();\n")
		case lexer.LOOP_OPEN:
			// optimize [-] which loops and decrements a cell until it is zero by just setting it to zero 0x00 explicitly
			if token_index+2 < len(program) {
				// - and ]
				if program[token_index+1].Type == lexer.DEC_CELL && program[token_index+2].Type == lexer.LOOP_CLOSE {
					buf.WriteString("   array[idx] = 0;")
					token_index += 3
					continue
				}
			}
			buf.WriteString("   while ( array[idx] ) {\n")
		case lexer.LOOP_CLOSE:
			buf.WriteString("}\n")
		default:
			// token not handled, decide what to do here
			// continue
			return nil, fmt.Errorf("unhandled token: %s at index %d", tok.Type, token_index)
		}
		token_index++
	}

	// close the main func
	buf.WriteString("}\n")

	return buf.Bytes(), nil
}

func (c *GenC) compileSrc(cpath string) error {

	gcc := exec.Command(
		"gcc",
		"-static",
		"-O3",
		"-s",
		"-o", c.output,
		cpath,
	)

	gcc.Stdout = os.Stdout
	gcc.Stderr = os.Stderr

	return gcc.Run()
}

func (c *GenC) Generate(input string, output string) error {
	c.input = input
	c.output = output
	tmp := c.output + ".c"

	b, err := c.generateSrc()
	if err != nil {
		return err
	}

	err = os.WriteFile(tmp, b, 0o644)
	if err != nil {
		return err
	}

	err = c.compileSrc(tmp)
	if err != nil {
		return err
	}

	return nil
}
